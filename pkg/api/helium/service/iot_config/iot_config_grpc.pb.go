// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.12.4
// source: service/iot_config.proto

package iot_config

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// OrgClient is the client API for Org service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type OrgClient interface {
	// List Org (no auth)
	List(ctx context.Context, in *OrgListReqV1, opts ...grpc.CallOption) (*OrgListResV1, error)
	// Get Org (no auth)
	Get(ctx context.Context, in *OrgGetReqV1, opts ...grpc.CallOption) (*OrgResV1, error)
	// Create Org on Helium Network (auth admin only)
	CreateHelium(ctx context.Context, in *OrgCreateHeliumReqV1, opts ...grpc.CallOption) (*OrgResV1, error)
	// Create Org on any network (auth admin only)
	CreateRoamer(ctx context.Context, in *OrgCreateRoamerReqV1, opts ...grpc.CallOption) (*OrgResV1, error)
	// Disable an org, this sends a stream route delete update to HPR
	// for all associated routes (auth admin only)
	Disable(ctx context.Context, in *OrgDisableReqV1, opts ...grpc.CallOption) (*OrgDisableResV1, error)
	// Enable an org, this sends a stream route create update to HPR
	// for all associated routes (auth admin only)
	Enable(ctx context.Context, in *OrgEnableReqV1, opts ...grpc.CallOption) (*OrgEnableResV1, error)
}

type orgClient struct {
	cc grpc.ClientConnInterface
}

func NewOrgClient(cc grpc.ClientConnInterface) OrgClient {
	return &orgClient{cc}
}

func (c *orgClient) List(ctx context.Context, in *OrgListReqV1, opts ...grpc.CallOption) (*OrgListResV1, error) {
	out := new(OrgListResV1)
	err := c.cc.Invoke(ctx, "/helium.iot_config.org/list", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orgClient) Get(ctx context.Context, in *OrgGetReqV1, opts ...grpc.CallOption) (*OrgResV1, error) {
	out := new(OrgResV1)
	err := c.cc.Invoke(ctx, "/helium.iot_config.org/get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orgClient) CreateHelium(ctx context.Context, in *OrgCreateHeliumReqV1, opts ...grpc.CallOption) (*OrgResV1, error) {
	out := new(OrgResV1)
	err := c.cc.Invoke(ctx, "/helium.iot_config.org/create_helium", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orgClient) CreateRoamer(ctx context.Context, in *OrgCreateRoamerReqV1, opts ...grpc.CallOption) (*OrgResV1, error) {
	out := new(OrgResV1)
	err := c.cc.Invoke(ctx, "/helium.iot_config.org/create_roamer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orgClient) Disable(ctx context.Context, in *OrgDisableReqV1, opts ...grpc.CallOption) (*OrgDisableResV1, error) {
	out := new(OrgDisableResV1)
	err := c.cc.Invoke(ctx, "/helium.iot_config.org/disable", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orgClient) Enable(ctx context.Context, in *OrgEnableReqV1, opts ...grpc.CallOption) (*OrgEnableResV1, error) {
	out := new(OrgEnableResV1)
	err := c.cc.Invoke(ctx, "/helium.iot_config.org/enable", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OrgServer is the server API for Org service.
// All implementations must embed UnimplementedOrgServer
// for forward compatibility
type OrgServer interface {
	// List Org (no auth)
	List(context.Context, *OrgListReqV1) (*OrgListResV1, error)
	// Get Org (no auth)
	Get(context.Context, *OrgGetReqV1) (*OrgResV1, error)
	// Create Org on Helium Network (auth admin only)
	CreateHelium(context.Context, *OrgCreateHeliumReqV1) (*OrgResV1, error)
	// Create Org on any network (auth admin only)
	CreateRoamer(context.Context, *OrgCreateRoamerReqV1) (*OrgResV1, error)
	// Disable an org, this sends a stream route delete update to HPR
	// for all associated routes (auth admin only)
	Disable(context.Context, *OrgDisableReqV1) (*OrgDisableResV1, error)
	// Enable an org, this sends a stream route create update to HPR
	// for all associated routes (auth admin only)
	Enable(context.Context, *OrgEnableReqV1) (*OrgEnableResV1, error)
	mustEmbedUnimplementedOrgServer()
}

// UnimplementedOrgServer must be embedded to have forward compatible implementations.
type UnimplementedOrgServer struct {
}

func (UnimplementedOrgServer) List(context.Context, *OrgListReqV1) (*OrgListResV1, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedOrgServer) Get(context.Context, *OrgGetReqV1) (*OrgResV1, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedOrgServer) CreateHelium(context.Context, *OrgCreateHeliumReqV1) (*OrgResV1, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateHelium not implemented")
}
func (UnimplementedOrgServer) CreateRoamer(context.Context, *OrgCreateRoamerReqV1) (*OrgResV1, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateRoamer not implemented")
}
func (UnimplementedOrgServer) Disable(context.Context, *OrgDisableReqV1) (*OrgDisableResV1, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Disable not implemented")
}
func (UnimplementedOrgServer) Enable(context.Context, *OrgEnableReqV1) (*OrgEnableResV1, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Enable not implemented")
}
func (UnimplementedOrgServer) mustEmbedUnimplementedOrgServer() {}

// UnsafeOrgServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OrgServer will
// result in compilation errors.
type UnsafeOrgServer interface {
	mustEmbedUnimplementedOrgServer()
}

func RegisterOrgServer(s grpc.ServiceRegistrar, srv OrgServer) {
	s.RegisterService(&Org_ServiceDesc, srv)
}

func _Org_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrgListReqV1)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrgServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/helium.iot_config.org/list",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrgServer).List(ctx, req.(*OrgListReqV1))
	}
	return interceptor(ctx, in, info, handler)
}

func _Org_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrgGetReqV1)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrgServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/helium.iot_config.org/get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrgServer).Get(ctx, req.(*OrgGetReqV1))
	}
	return interceptor(ctx, in, info, handler)
}

func _Org_CreateHelium_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrgCreateHeliumReqV1)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrgServer).CreateHelium(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/helium.iot_config.org/create_helium",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrgServer).CreateHelium(ctx, req.(*OrgCreateHeliumReqV1))
	}
	return interceptor(ctx, in, info, handler)
}

func _Org_CreateRoamer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrgCreateRoamerReqV1)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrgServer).CreateRoamer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/helium.iot_config.org/create_roamer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrgServer).CreateRoamer(ctx, req.(*OrgCreateRoamerReqV1))
	}
	return interceptor(ctx, in, info, handler)
}

func _Org_Disable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrgDisableReqV1)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrgServer).Disable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/helium.iot_config.org/disable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrgServer).Disable(ctx, req.(*OrgDisableReqV1))
	}
	return interceptor(ctx, in, info, handler)
}

func _Org_Enable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrgEnableReqV1)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrgServer).Enable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/helium.iot_config.org/enable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrgServer).Enable(ctx, req.(*OrgEnableReqV1))
	}
	return interceptor(ctx, in, info, handler)
}

// Org_ServiceDesc is the grpc.ServiceDesc for Org service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Org_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "helium.iot_config.org",
	HandlerType: (*OrgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "list",
			Handler:    _Org_List_Handler,
		},
		{
			MethodName: "get",
			Handler:    _Org_Get_Handler,
		},
		{
			MethodName: "create_helium",
			Handler:    _Org_CreateHelium_Handler,
		},
		{
			MethodName: "create_roamer",
			Handler:    _Org_CreateRoamer_Handler,
		},
		{
			MethodName: "disable",
			Handler:    _Org_Disable_Handler,
		},
		{
			MethodName: "enable",
			Handler:    _Org_Enable_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service/iot_config.proto",
}

// RouteClient is the client API for Route service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RouteClient interface {
	// List Routes for an Org (auth delegate_keys/owner/admin)
	List(ctx context.Context, in *RouteListReqV1, opts ...grpc.CallOption) (*RouteListResV1, error)
	// Get Route for an Org (auth delegate_keys/owner/admin)
	Get(ctx context.Context, in *RouteGetReqV1, opts ...grpc.CallOption) (*RouteV1, error)
	// Create Route for an Org (auth delegate_keys/owner/admin)
	Create(ctx context.Context, in *RouteCreateReqV1, opts ...grpc.CallOption) (*RouteV1, error)
	// Update Route for an Org (auth delegate_keys/owner/admin)
	Update(ctx context.Context, in *RouteUpdateReqV1, opts ...grpc.CallOption) (*RouteV1, error)
	// Delete Route for an Org (auth delegate_keys/owner/admin)
	Delete(ctx context.Context, in *RouteDeleteReqV1, opts ...grpc.CallOption) (*RouteV1, error)
	// Get EUIs for a Route (auth delegate_keys/owner/admin)
	GetEuis(ctx context.Context, in *RouteGetEuisReqV1, opts ...grpc.CallOption) (Route_GetEuisClient, error)
	// Update (single add or remove) EUIs for a Route (auth
	// delegate_keys/owner/admin)
	UpdateEuis(ctx context.Context, opts ...grpc.CallOption) (Route_UpdateEuisClient, error)
	// Delete all EUIs for a Route (auth delegate_keys/owner/admin)
	DeleteEuis(ctx context.Context, in *RouteDeleteEuisReqV1, opts ...grpc.CallOption) (*RouteEuisResV1, error)
	// Get DevAddr Ranges for a Route (auth delegate_keys/owner/admin)
	GetDevaddrRanges(ctx context.Context, in *RouteGetDevaddrRangesReqV1, opts ...grpc.CallOption) (Route_GetDevaddrRangesClient, error)
	// Update (single add or remove) DevAddr Ranges for a Route (auth
	// delegate_keys/owner/admin)
	UpdateDevaddrRanges(ctx context.Context, opts ...grpc.CallOption) (Route_UpdateDevaddrRangesClient, error)
	// Delete all DevAddr Ranges for a Route (auth delegate_keys/owner/admin)
	DeleteDevaddrRanges(ctx context.Context, in *RouteDeleteDevaddrRangesReqV1, opts ...grpc.CallOption) (*RouteDevaddrRangesResV1, error)
	// Stream Routes update (auth admin only)
	Stream(ctx context.Context, in *RouteStreamReqV1, opts ...grpc.CallOption) (Route_StreamClient, error)
}

type routeClient struct {
	cc grpc.ClientConnInterface
}

func NewRouteClient(cc grpc.ClientConnInterface) RouteClient {
	return &routeClient{cc}
}

func (c *routeClient) List(ctx context.Context, in *RouteListReqV1, opts ...grpc.CallOption) (*RouteListResV1, error) {
	out := new(RouteListResV1)
	err := c.cc.Invoke(ctx, "/helium.iot_config.route/list", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routeClient) Get(ctx context.Context, in *RouteGetReqV1, opts ...grpc.CallOption) (*RouteV1, error) {
	out := new(RouteV1)
	err := c.cc.Invoke(ctx, "/helium.iot_config.route/get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routeClient) Create(ctx context.Context, in *RouteCreateReqV1, opts ...grpc.CallOption) (*RouteV1, error) {
	out := new(RouteV1)
	err := c.cc.Invoke(ctx, "/helium.iot_config.route/create", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routeClient) Update(ctx context.Context, in *RouteUpdateReqV1, opts ...grpc.CallOption) (*RouteV1, error) {
	out := new(RouteV1)
	err := c.cc.Invoke(ctx, "/helium.iot_config.route/update", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routeClient) Delete(ctx context.Context, in *RouteDeleteReqV1, opts ...grpc.CallOption) (*RouteV1, error) {
	out := new(RouteV1)
	err := c.cc.Invoke(ctx, "/helium.iot_config.route/delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routeClient) GetEuis(ctx context.Context, in *RouteGetEuisReqV1, opts ...grpc.CallOption) (Route_GetEuisClient, error) {
	stream, err := c.cc.NewStream(ctx, &Route_ServiceDesc.Streams[0], "/helium.iot_config.route/get_euis", opts...)
	if err != nil {
		return nil, err
	}
	x := &routeGetEuisClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Route_GetEuisClient interface {
	Recv() (*EuiPairV1, error)
	grpc.ClientStream
}

type routeGetEuisClient struct {
	grpc.ClientStream
}

func (x *routeGetEuisClient) Recv() (*EuiPairV1, error) {
	m := new(EuiPairV1)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *routeClient) UpdateEuis(ctx context.Context, opts ...grpc.CallOption) (Route_UpdateEuisClient, error) {
	stream, err := c.cc.NewStream(ctx, &Route_ServiceDesc.Streams[1], "/helium.iot_config.route/update_euis", opts...)
	if err != nil {
		return nil, err
	}
	x := &routeUpdateEuisClient{stream}
	return x, nil
}

type Route_UpdateEuisClient interface {
	Send(*RouteUpdateEuisReqV1) error
	CloseAndRecv() (*RouteEuisResV1, error)
	grpc.ClientStream
}

type routeUpdateEuisClient struct {
	grpc.ClientStream
}

func (x *routeUpdateEuisClient) Send(m *RouteUpdateEuisReqV1) error {
	return x.ClientStream.SendMsg(m)
}

func (x *routeUpdateEuisClient) CloseAndRecv() (*RouteEuisResV1, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(RouteEuisResV1)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *routeClient) DeleteEuis(ctx context.Context, in *RouteDeleteEuisReqV1, opts ...grpc.CallOption) (*RouteEuisResV1, error) {
	out := new(RouteEuisResV1)
	err := c.cc.Invoke(ctx, "/helium.iot_config.route/delete_euis", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routeClient) GetDevaddrRanges(ctx context.Context, in *RouteGetDevaddrRangesReqV1, opts ...grpc.CallOption) (Route_GetDevaddrRangesClient, error) {
	stream, err := c.cc.NewStream(ctx, &Route_ServiceDesc.Streams[2], "/helium.iot_config.route/get_devaddr_ranges", opts...)
	if err != nil {
		return nil, err
	}
	x := &routeGetDevaddrRangesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Route_GetDevaddrRangesClient interface {
	Recv() (*DevaddrRangeV1, error)
	grpc.ClientStream
}

type routeGetDevaddrRangesClient struct {
	grpc.ClientStream
}

func (x *routeGetDevaddrRangesClient) Recv() (*DevaddrRangeV1, error) {
	m := new(DevaddrRangeV1)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *routeClient) UpdateDevaddrRanges(ctx context.Context, opts ...grpc.CallOption) (Route_UpdateDevaddrRangesClient, error) {
	stream, err := c.cc.NewStream(ctx, &Route_ServiceDesc.Streams[3], "/helium.iot_config.route/update_devaddr_ranges", opts...)
	if err != nil {
		return nil, err
	}
	x := &routeUpdateDevaddrRangesClient{stream}
	return x, nil
}

type Route_UpdateDevaddrRangesClient interface {
	Send(*RouteUpdateDevaddrRangesReqV1) error
	CloseAndRecv() (*RouteDevaddrRangesResV1, error)
	grpc.ClientStream
}

type routeUpdateDevaddrRangesClient struct {
	grpc.ClientStream
}

func (x *routeUpdateDevaddrRangesClient) Send(m *RouteUpdateDevaddrRangesReqV1) error {
	return x.ClientStream.SendMsg(m)
}

func (x *routeUpdateDevaddrRangesClient) CloseAndRecv() (*RouteDevaddrRangesResV1, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(RouteDevaddrRangesResV1)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *routeClient) DeleteDevaddrRanges(ctx context.Context, in *RouteDeleteDevaddrRangesReqV1, opts ...grpc.CallOption) (*RouteDevaddrRangesResV1, error) {
	out := new(RouteDevaddrRangesResV1)
	err := c.cc.Invoke(ctx, "/helium.iot_config.route/delete_devaddr_ranges", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routeClient) Stream(ctx context.Context, in *RouteStreamReqV1, opts ...grpc.CallOption) (Route_StreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &Route_ServiceDesc.Streams[4], "/helium.iot_config.route/stream", opts...)
	if err != nil {
		return nil, err
	}
	x := &routeStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Route_StreamClient interface {
	Recv() (*RouteStreamResV1, error)
	grpc.ClientStream
}

type routeStreamClient struct {
	grpc.ClientStream
}

func (x *routeStreamClient) Recv() (*RouteStreamResV1, error) {
	m := new(RouteStreamResV1)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// RouteServer is the server API for Route service.
// All implementations must embed UnimplementedRouteServer
// for forward compatibility
type RouteServer interface {
	// List Routes for an Org (auth delegate_keys/owner/admin)
	List(context.Context, *RouteListReqV1) (*RouteListResV1, error)
	// Get Route for an Org (auth delegate_keys/owner/admin)
	Get(context.Context, *RouteGetReqV1) (*RouteV1, error)
	// Create Route for an Org (auth delegate_keys/owner/admin)
	Create(context.Context, *RouteCreateReqV1) (*RouteV1, error)
	// Update Route for an Org (auth delegate_keys/owner/admin)
	Update(context.Context, *RouteUpdateReqV1) (*RouteV1, error)
	// Delete Route for an Org (auth delegate_keys/owner/admin)
	Delete(context.Context, *RouteDeleteReqV1) (*RouteV1, error)
	// Get EUIs for a Route (auth delegate_keys/owner/admin)
	GetEuis(*RouteGetEuisReqV1, Route_GetEuisServer) error
	// Update (single add or remove) EUIs for a Route (auth
	// delegate_keys/owner/admin)
	UpdateEuis(Route_UpdateEuisServer) error
	// Delete all EUIs for a Route (auth delegate_keys/owner/admin)
	DeleteEuis(context.Context, *RouteDeleteEuisReqV1) (*RouteEuisResV1, error)
	// Get DevAddr Ranges for a Route (auth delegate_keys/owner/admin)
	GetDevaddrRanges(*RouteGetDevaddrRangesReqV1, Route_GetDevaddrRangesServer) error
	// Update (single add or remove) DevAddr Ranges for a Route (auth
	// delegate_keys/owner/admin)
	UpdateDevaddrRanges(Route_UpdateDevaddrRangesServer) error
	// Delete all DevAddr Ranges for a Route (auth delegate_keys/owner/admin)
	DeleteDevaddrRanges(context.Context, *RouteDeleteDevaddrRangesReqV1) (*RouteDevaddrRangesResV1, error)
	// Stream Routes update (auth admin only)
	Stream(*RouteStreamReqV1, Route_StreamServer) error
	mustEmbedUnimplementedRouteServer()
}

// UnimplementedRouteServer must be embedded to have forward compatible implementations.
type UnimplementedRouteServer struct {
}

func (UnimplementedRouteServer) List(context.Context, *RouteListReqV1) (*RouteListResV1, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedRouteServer) Get(context.Context, *RouteGetReqV1) (*RouteV1, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedRouteServer) Create(context.Context, *RouteCreateReqV1) (*RouteV1, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedRouteServer) Update(context.Context, *RouteUpdateReqV1) (*RouteV1, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedRouteServer) Delete(context.Context, *RouteDeleteReqV1) (*RouteV1, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedRouteServer) GetEuis(*RouteGetEuisReqV1, Route_GetEuisServer) error {
	return status.Errorf(codes.Unimplemented, "method GetEuis not implemented")
}
func (UnimplementedRouteServer) UpdateEuis(Route_UpdateEuisServer) error {
	return status.Errorf(codes.Unimplemented, "method UpdateEuis not implemented")
}
func (UnimplementedRouteServer) DeleteEuis(context.Context, *RouteDeleteEuisReqV1) (*RouteEuisResV1, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteEuis not implemented")
}
func (UnimplementedRouteServer) GetDevaddrRanges(*RouteGetDevaddrRangesReqV1, Route_GetDevaddrRangesServer) error {
	return status.Errorf(codes.Unimplemented, "method GetDevaddrRanges not implemented")
}
func (UnimplementedRouteServer) UpdateDevaddrRanges(Route_UpdateDevaddrRangesServer) error {
	return status.Errorf(codes.Unimplemented, "method UpdateDevaddrRanges not implemented")
}
func (UnimplementedRouteServer) DeleteDevaddrRanges(context.Context, *RouteDeleteDevaddrRangesReqV1) (*RouteDevaddrRangesResV1, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteDevaddrRanges not implemented")
}
func (UnimplementedRouteServer) Stream(*RouteStreamReqV1, Route_StreamServer) error {
	return status.Errorf(codes.Unimplemented, "method Stream not implemented")
}
func (UnimplementedRouteServer) mustEmbedUnimplementedRouteServer() {}

// UnsafeRouteServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RouteServer will
// result in compilation errors.
type UnsafeRouteServer interface {
	mustEmbedUnimplementedRouteServer()
}

func RegisterRouteServer(s grpc.ServiceRegistrar, srv RouteServer) {
	s.RegisterService(&Route_ServiceDesc, srv)
}

func _Route_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteListReqV1)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouteServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/helium.iot_config.route/list",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouteServer).List(ctx, req.(*RouteListReqV1))
	}
	return interceptor(ctx, in, info, handler)
}

func _Route_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteGetReqV1)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouteServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/helium.iot_config.route/get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouteServer).Get(ctx, req.(*RouteGetReqV1))
	}
	return interceptor(ctx, in, info, handler)
}

func _Route_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteCreateReqV1)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouteServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/helium.iot_config.route/create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouteServer).Create(ctx, req.(*RouteCreateReqV1))
	}
	return interceptor(ctx, in, info, handler)
}

func _Route_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteUpdateReqV1)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouteServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/helium.iot_config.route/update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouteServer).Update(ctx, req.(*RouteUpdateReqV1))
	}
	return interceptor(ctx, in, info, handler)
}

func _Route_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteDeleteReqV1)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouteServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/helium.iot_config.route/delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouteServer).Delete(ctx, req.(*RouteDeleteReqV1))
	}
	return interceptor(ctx, in, info, handler)
}

func _Route_GetEuis_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RouteGetEuisReqV1)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RouteServer).GetEuis(m, &routeGetEuisServer{stream})
}

type Route_GetEuisServer interface {
	Send(*EuiPairV1) error
	grpc.ServerStream
}

type routeGetEuisServer struct {
	grpc.ServerStream
}

func (x *routeGetEuisServer) Send(m *EuiPairV1) error {
	return x.ServerStream.SendMsg(m)
}

func _Route_UpdateEuis_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RouteServer).UpdateEuis(&routeUpdateEuisServer{stream})
}

type Route_UpdateEuisServer interface {
	SendAndClose(*RouteEuisResV1) error
	Recv() (*RouteUpdateEuisReqV1, error)
	grpc.ServerStream
}

type routeUpdateEuisServer struct {
	grpc.ServerStream
}

func (x *routeUpdateEuisServer) SendAndClose(m *RouteEuisResV1) error {
	return x.ServerStream.SendMsg(m)
}

func (x *routeUpdateEuisServer) Recv() (*RouteUpdateEuisReqV1, error) {
	m := new(RouteUpdateEuisReqV1)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Route_DeleteEuis_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteDeleteEuisReqV1)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouteServer).DeleteEuis(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/helium.iot_config.route/delete_euis",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouteServer).DeleteEuis(ctx, req.(*RouteDeleteEuisReqV1))
	}
	return interceptor(ctx, in, info, handler)
}

func _Route_GetDevaddrRanges_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RouteGetDevaddrRangesReqV1)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RouteServer).GetDevaddrRanges(m, &routeGetDevaddrRangesServer{stream})
}

type Route_GetDevaddrRangesServer interface {
	Send(*DevaddrRangeV1) error
	grpc.ServerStream
}

type routeGetDevaddrRangesServer struct {
	grpc.ServerStream
}

func (x *routeGetDevaddrRangesServer) Send(m *DevaddrRangeV1) error {
	return x.ServerStream.SendMsg(m)
}

func _Route_UpdateDevaddrRanges_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RouteServer).UpdateDevaddrRanges(&routeUpdateDevaddrRangesServer{stream})
}

type Route_UpdateDevaddrRangesServer interface {
	SendAndClose(*RouteDevaddrRangesResV1) error
	Recv() (*RouteUpdateDevaddrRangesReqV1, error)
	grpc.ServerStream
}

type routeUpdateDevaddrRangesServer struct {
	grpc.ServerStream
}

func (x *routeUpdateDevaddrRangesServer) SendAndClose(m *RouteDevaddrRangesResV1) error {
	return x.ServerStream.SendMsg(m)
}

func (x *routeUpdateDevaddrRangesServer) Recv() (*RouteUpdateDevaddrRangesReqV1, error) {
	m := new(RouteUpdateDevaddrRangesReqV1)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Route_DeleteDevaddrRanges_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteDeleteDevaddrRangesReqV1)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouteServer).DeleteDevaddrRanges(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/helium.iot_config.route/delete_devaddr_ranges",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouteServer).DeleteDevaddrRanges(ctx, req.(*RouteDeleteDevaddrRangesReqV1))
	}
	return interceptor(ctx, in, info, handler)
}

func _Route_Stream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RouteStreamReqV1)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RouteServer).Stream(m, &routeStreamServer{stream})
}

type Route_StreamServer interface {
	Send(*RouteStreamResV1) error
	grpc.ServerStream
}

type routeStreamServer struct {
	grpc.ServerStream
}

func (x *routeStreamServer) Send(m *RouteStreamResV1) error {
	return x.ServerStream.SendMsg(m)
}

// Route_ServiceDesc is the grpc.ServiceDesc for Route service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Route_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "helium.iot_config.route",
	HandlerType: (*RouteServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "list",
			Handler:    _Route_List_Handler,
		},
		{
			MethodName: "get",
			Handler:    _Route_Get_Handler,
		},
		{
			MethodName: "create",
			Handler:    _Route_Create_Handler,
		},
		{
			MethodName: "update",
			Handler:    _Route_Update_Handler,
		},
		{
			MethodName: "delete",
			Handler:    _Route_Delete_Handler,
		},
		{
			MethodName: "delete_euis",
			Handler:    _Route_DeleteEuis_Handler,
		},
		{
			MethodName: "delete_devaddr_ranges",
			Handler:    _Route_DeleteDevaddrRanges_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "get_euis",
			Handler:       _Route_GetEuis_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "update_euis",
			Handler:       _Route_UpdateEuis_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "get_devaddr_ranges",
			Handler:       _Route_GetDevaddrRanges_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "update_devaddr_ranges",
			Handler:       _Route_UpdateDevaddrRanges_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "stream",
			Handler:       _Route_Stream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "service/iot_config.proto",
}

// SessionKeyFilterClient is the client API for SessionKeyFilter service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SessionKeyFilterClient interface {
	// List Filters for an Org (auth delegate_keys/owner/admin)
	List(ctx context.Context, in *SessionKeyFilterListReqV1, opts ...grpc.CallOption) (SessionKeyFilter_ListClient, error)
	// List Filters for a DevAddr (auth delegate_keys/owner/admin
	Get(ctx context.Context, in *SessionKeyFilterGetReqV1, opts ...grpc.CallOption) (SessionKeyFilter_GetClient, error)
	// Update Filters for an Org (auth delegate_keys/owner/admin)
	Update(ctx context.Context, opts ...grpc.CallOption) (SessionKeyFilter_UpdateClient, error)
	// Stream Filter update (auth admin only)
	Stream(ctx context.Context, in *SessionKeyFilterStreamReqV1, opts ...grpc.CallOption) (SessionKeyFilter_StreamClient, error)
}

type sessionKeyFilterClient struct {
	cc grpc.ClientConnInterface
}

func NewSessionKeyFilterClient(cc grpc.ClientConnInterface) SessionKeyFilterClient {
	return &sessionKeyFilterClient{cc}
}

func (c *sessionKeyFilterClient) List(ctx context.Context, in *SessionKeyFilterListReqV1, opts ...grpc.CallOption) (SessionKeyFilter_ListClient, error) {
	stream, err := c.cc.NewStream(ctx, &SessionKeyFilter_ServiceDesc.Streams[0], "/helium.iot_config.session_key_filter/list", opts...)
	if err != nil {
		return nil, err
	}
	x := &sessionKeyFilterListClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type SessionKeyFilter_ListClient interface {
	Recv() (*SessionKeyFilterV1, error)
	grpc.ClientStream
}

type sessionKeyFilterListClient struct {
	grpc.ClientStream
}

func (x *sessionKeyFilterListClient) Recv() (*SessionKeyFilterV1, error) {
	m := new(SessionKeyFilterV1)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *sessionKeyFilterClient) Get(ctx context.Context, in *SessionKeyFilterGetReqV1, opts ...grpc.CallOption) (SessionKeyFilter_GetClient, error) {
	stream, err := c.cc.NewStream(ctx, &SessionKeyFilter_ServiceDesc.Streams[1], "/helium.iot_config.session_key_filter/get", opts...)
	if err != nil {
		return nil, err
	}
	x := &sessionKeyFilterGetClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type SessionKeyFilter_GetClient interface {
	Recv() (*SessionKeyFilterV1, error)
	grpc.ClientStream
}

type sessionKeyFilterGetClient struct {
	grpc.ClientStream
}

func (x *sessionKeyFilterGetClient) Recv() (*SessionKeyFilterV1, error) {
	m := new(SessionKeyFilterV1)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *sessionKeyFilterClient) Update(ctx context.Context, opts ...grpc.CallOption) (SessionKeyFilter_UpdateClient, error) {
	stream, err := c.cc.NewStream(ctx, &SessionKeyFilter_ServiceDesc.Streams[2], "/helium.iot_config.session_key_filter/update", opts...)
	if err != nil {
		return nil, err
	}
	x := &sessionKeyFilterUpdateClient{stream}
	return x, nil
}

type SessionKeyFilter_UpdateClient interface {
	Send(*SessionKeyFilterUpdateReqV1) error
	CloseAndRecv() (*SessionKeyFilterUpdateResV1, error)
	grpc.ClientStream
}

type sessionKeyFilterUpdateClient struct {
	grpc.ClientStream
}

func (x *sessionKeyFilterUpdateClient) Send(m *SessionKeyFilterUpdateReqV1) error {
	return x.ClientStream.SendMsg(m)
}

func (x *sessionKeyFilterUpdateClient) CloseAndRecv() (*SessionKeyFilterUpdateResV1, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(SessionKeyFilterUpdateResV1)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *sessionKeyFilterClient) Stream(ctx context.Context, in *SessionKeyFilterStreamReqV1, opts ...grpc.CallOption) (SessionKeyFilter_StreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &SessionKeyFilter_ServiceDesc.Streams[3], "/helium.iot_config.session_key_filter/stream", opts...)
	if err != nil {
		return nil, err
	}
	x := &sessionKeyFilterStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type SessionKeyFilter_StreamClient interface {
	Recv() (*SessionKeyFilterStreamResV1, error)
	grpc.ClientStream
}

type sessionKeyFilterStreamClient struct {
	grpc.ClientStream
}

func (x *sessionKeyFilterStreamClient) Recv() (*SessionKeyFilterStreamResV1, error) {
	m := new(SessionKeyFilterStreamResV1)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// SessionKeyFilterServer is the server API for SessionKeyFilter service.
// All implementations must embed UnimplementedSessionKeyFilterServer
// for forward compatibility
type SessionKeyFilterServer interface {
	// List Filters for an Org (auth delegate_keys/owner/admin)
	List(*SessionKeyFilterListReqV1, SessionKeyFilter_ListServer) error
	// List Filters for a DevAddr (auth delegate_keys/owner/admin
	Get(*SessionKeyFilterGetReqV1, SessionKeyFilter_GetServer) error
	// Update Filters for an Org (auth delegate_keys/owner/admin)
	Update(SessionKeyFilter_UpdateServer) error
	// Stream Filter update (auth admin only)
	Stream(*SessionKeyFilterStreamReqV1, SessionKeyFilter_StreamServer) error
	mustEmbedUnimplementedSessionKeyFilterServer()
}

// UnimplementedSessionKeyFilterServer must be embedded to have forward compatible implementations.
type UnimplementedSessionKeyFilterServer struct {
}

func (UnimplementedSessionKeyFilterServer) List(*SessionKeyFilterListReqV1, SessionKeyFilter_ListServer) error {
	return status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedSessionKeyFilterServer) Get(*SessionKeyFilterGetReqV1, SessionKeyFilter_GetServer) error {
	return status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedSessionKeyFilterServer) Update(SessionKeyFilter_UpdateServer) error {
	return status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedSessionKeyFilterServer) Stream(*SessionKeyFilterStreamReqV1, SessionKeyFilter_StreamServer) error {
	return status.Errorf(codes.Unimplemented, "method Stream not implemented")
}
func (UnimplementedSessionKeyFilterServer) mustEmbedUnimplementedSessionKeyFilterServer() {}

// UnsafeSessionKeyFilterServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SessionKeyFilterServer will
// result in compilation errors.
type UnsafeSessionKeyFilterServer interface {
	mustEmbedUnimplementedSessionKeyFilterServer()
}

func RegisterSessionKeyFilterServer(s grpc.ServiceRegistrar, srv SessionKeyFilterServer) {
	s.RegisterService(&SessionKeyFilter_ServiceDesc, srv)
}

func _SessionKeyFilter_List_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SessionKeyFilterListReqV1)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SessionKeyFilterServer).List(m, &sessionKeyFilterListServer{stream})
}

type SessionKeyFilter_ListServer interface {
	Send(*SessionKeyFilterV1) error
	grpc.ServerStream
}

type sessionKeyFilterListServer struct {
	grpc.ServerStream
}

func (x *sessionKeyFilterListServer) Send(m *SessionKeyFilterV1) error {
	return x.ServerStream.SendMsg(m)
}

func _SessionKeyFilter_Get_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SessionKeyFilterGetReqV1)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SessionKeyFilterServer).Get(m, &sessionKeyFilterGetServer{stream})
}

type SessionKeyFilter_GetServer interface {
	Send(*SessionKeyFilterV1) error
	grpc.ServerStream
}

type sessionKeyFilterGetServer struct {
	grpc.ServerStream
}

func (x *sessionKeyFilterGetServer) Send(m *SessionKeyFilterV1) error {
	return x.ServerStream.SendMsg(m)
}

func _SessionKeyFilter_Update_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SessionKeyFilterServer).Update(&sessionKeyFilterUpdateServer{stream})
}

type SessionKeyFilter_UpdateServer interface {
	SendAndClose(*SessionKeyFilterUpdateResV1) error
	Recv() (*SessionKeyFilterUpdateReqV1, error)
	grpc.ServerStream
}

type sessionKeyFilterUpdateServer struct {
	grpc.ServerStream
}

func (x *sessionKeyFilterUpdateServer) SendAndClose(m *SessionKeyFilterUpdateResV1) error {
	return x.ServerStream.SendMsg(m)
}

func (x *sessionKeyFilterUpdateServer) Recv() (*SessionKeyFilterUpdateReqV1, error) {
	m := new(SessionKeyFilterUpdateReqV1)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _SessionKeyFilter_Stream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SessionKeyFilterStreamReqV1)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SessionKeyFilterServer).Stream(m, &sessionKeyFilterStreamServer{stream})
}

type SessionKeyFilter_StreamServer interface {
	Send(*SessionKeyFilterStreamResV1) error
	grpc.ServerStream
}

type sessionKeyFilterStreamServer struct {
	grpc.ServerStream
}

func (x *sessionKeyFilterStreamServer) Send(m *SessionKeyFilterStreamResV1) error {
	return x.ServerStream.SendMsg(m)
}

// SessionKeyFilter_ServiceDesc is the grpc.ServiceDesc for SessionKeyFilter service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SessionKeyFilter_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "helium.iot_config.session_key_filter",
	HandlerType: (*SessionKeyFilterServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "list",
			Handler:       _SessionKeyFilter_List_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "get",
			Handler:       _SessionKeyFilter_Get_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "update",
			Handler:       _SessionKeyFilter_Update_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "stream",
			Handler:       _SessionKeyFilter_Stream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "service/iot_config.proto",
}

// GatewayClient is the client API for Gateway service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GatewayClient interface {
	// Return the region params for the asserted location of the signed gateway
	// address (no auth, but signature validated)
	RegionParams(ctx context.Context, in *GatewayRegionParamsReqV1, opts ...grpc.CallOption) (*GatewayRegionParamsResV1, error)
	// Load params and cell indexes for a region into the config service (auth
	// admin only)
	LoadRegion(ctx context.Context, in *GatewayLoadRegionReqV1, opts ...grpc.CallOption) (*GatewayLoadRegionResV1, error)
}

type gatewayClient struct {
	cc grpc.ClientConnInterface
}

func NewGatewayClient(cc grpc.ClientConnInterface) GatewayClient {
	return &gatewayClient{cc}
}

func (c *gatewayClient) RegionParams(ctx context.Context, in *GatewayRegionParamsReqV1, opts ...grpc.CallOption) (*GatewayRegionParamsResV1, error) {
	out := new(GatewayRegionParamsResV1)
	err := c.cc.Invoke(ctx, "/helium.iot_config.gateway/region_params", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) LoadRegion(ctx context.Context, in *GatewayLoadRegionReqV1, opts ...grpc.CallOption) (*GatewayLoadRegionResV1, error) {
	out := new(GatewayLoadRegionResV1)
	err := c.cc.Invoke(ctx, "/helium.iot_config.gateway/load_region", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GatewayServer is the server API for Gateway service.
// All implementations must embed UnimplementedGatewayServer
// for forward compatibility
type GatewayServer interface {
	// Return the region params for the asserted location of the signed gateway
	// address (no auth, but signature validated)
	RegionParams(context.Context, *GatewayRegionParamsReqV1) (*GatewayRegionParamsResV1, error)
	// Load params and cell indexes for a region into the config service (auth
	// admin only)
	LoadRegion(context.Context, *GatewayLoadRegionReqV1) (*GatewayLoadRegionResV1, error)
	mustEmbedUnimplementedGatewayServer()
}

// UnimplementedGatewayServer must be embedded to have forward compatible implementations.
type UnimplementedGatewayServer struct {
}

func (UnimplementedGatewayServer) RegionParams(context.Context, *GatewayRegionParamsReqV1) (*GatewayRegionParamsResV1, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegionParams not implemented")
}
func (UnimplementedGatewayServer) LoadRegion(context.Context, *GatewayLoadRegionReqV1) (*GatewayLoadRegionResV1, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoadRegion not implemented")
}
func (UnimplementedGatewayServer) mustEmbedUnimplementedGatewayServer() {}

// UnsafeGatewayServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GatewayServer will
// result in compilation errors.
type UnsafeGatewayServer interface {
	mustEmbedUnimplementedGatewayServer()
}

func RegisterGatewayServer(s grpc.ServiceRegistrar, srv GatewayServer) {
	s.RegisterService(&Gateway_ServiceDesc, srv)
}

func _Gateway_RegionParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GatewayRegionParamsReqV1)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).RegionParams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/helium.iot_config.gateway/region_params",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).RegionParams(ctx, req.(*GatewayRegionParamsReqV1))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_LoadRegion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GatewayLoadRegionReqV1)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).LoadRegion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/helium.iot_config.gateway/load_region",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).LoadRegion(ctx, req.(*GatewayLoadRegionReqV1))
	}
	return interceptor(ctx, in, info, handler)
}

// Gateway_ServiceDesc is the grpc.ServiceDesc for Gateway service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Gateway_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "helium.iot_config.gateway",
	HandlerType: (*GatewayServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "region_params",
			Handler:    _Gateway_RegionParams_Handler,
		},
		{
			MethodName: "load_region",
			Handler:    _Gateway_LoadRegion_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service/iot_config.proto",
}
